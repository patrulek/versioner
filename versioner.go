package main

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/patrulek/versioner/version"
)

var now = time.Now().Format(time.DateTime)
var ver version.Version

func main() {
	if len(os.Args) < 2 {
		os.Exit(1)
	}

	path := os.Args[1]

	tagver, revision, timestamp := gitversion(path)
	ver.Timestamp = timeRevision(timestamp)

	if tagver != "" {
		if revision == "" {
			ver.Revision = timeRevision(timestamp)
			ver.Ver = tagver
		} else {
			ver.Revision = revision
			ver.Ver = fmt.Sprintf("%s-%s", tagver, ver.Revision)
		}
	} else {
		if revision == "" {
			ver.Revision = timeRevision(timestamp)
		} else {
			ver.Revision = revision
		}

		ver.Ver = fmt.Sprintf("%s-%s", "v0.0.0", ver.Revision)
	}

	file, err := os.Create(strings.Join([]string{path, "version_gen.go"}, "/"))
	if err != nil {
		os.Exit(1)
	}
	defer file.Close()

	verRaw, err := json.Marshal(ver)
	if err != nil {
		os.Exit(1)
	}

	var m map[string]string
	if err := json.Unmarshal(verRaw, &m); err != nil {
		os.Exit(1)
	}

	preamble := fmt.Sprintf("// File generated by versioner at %s\n\n", time.Now().Format(time.DateTime))
	pack := "package main\n\n"
	imp := "import \"github.com/patrulek/versioner/version\"\n\n"
	content := "var __version__ version.Version = version.Version{\n"
	for k, v := range m {
		if v == "" {
			continue
		}

		content += fmt.Sprintf("\t%s: %q,\n", k, v)
	}
	content += "}\n"

	if _, err := file.Write([]byte(preamble + pack + imp + content)); err != nil {
		os.Exit(1)
	}
}

func timeRevision(timestamp string) string {
	return strings.ReplaceAll(strings.ReplaceAll(strings.ReplaceAll(timestamp, "-", ""), ":", ""), " ", "_")
}

func gitversion(path string) (tagver, revision, timestamp string) {
	repo, err := git.PlainOpen(path)
	if err != nil {
		return "", "", time.Now().Format(time.DateTime)
	}

	it, err := repo.TagObjects()
	if err != nil {
		return "", headRevision(repo), gitTimeRevision(repo)
	}

	var latestTag *object.Tag
	var latestCommit *object.Commit

	if err := it.ForEach(func(t *object.Tag) error {
		commit, err := t.Commit()
		if err != nil {
			return err
		}

		if latestTag == nil || commit.Committer.When.After(latestCommit.Committer.When) {
			latestTag = t
			latestCommit = commit
		}

		return nil
	}); err != nil {
		return "", headRevision(repo), gitTimeRevision(repo)
	}

	if latestTag == nil {
		return "", headRevision(repo), gitTimeRevision(repo)
	}

	head, err := repo.Head()
	if err != nil {
		panic(err)
	}

	headCommit, err := repo.CommitObject(head.Hash())
	if err != nil {
		panic(err)
	}

	if headCommit.Committer.When.After(latestCommit.Committer.When) {
		return latestTag.Name, headRevision(repo), gitTimeRevision(repo)
	}

	return latestTag.Name, "", gitTimeRevision(repo)
}

func headRevision(repo *git.Repository) string {
	ref, err := repo.Head()
	if err != nil {
		return ""
	}

	wt, err := repo.Worktree()
	if err != nil {
		return ""
	}

	st, err := wt.Status()
	if err != nil {
		return ""
	}

	rev := []string{
		ref.Hash().String()[:8],
	}

	branch := string(ref.Name())
	branch = branch[strings.LastIndex(branch, "/")+1:]

	if branch != "main" && branch != "master" {
		rev = append(rev, branch)
	}

	if !st.IsClean() {
		rev = append(rev, "uncommitted")
	}

	return strings.Join(rev, "-")
}

func gitTimeRevision(repo *git.Repository) string {
	ref, err := repo.Head()
	if err != nil {
		return now
	}

	headCommit, err := repo.CommitObject(ref.Hash())
	if err != nil {
		return now
	}

	return headCommit.Committer.When.UTC().Format(time.DateTime)
}
